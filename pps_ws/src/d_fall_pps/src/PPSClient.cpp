//    ROS node that manages the student's setup.
//    Copyright (C) 2017  Cyrill Burgener, Marco Mueller, Philipp Friedli
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.


//TODO:
//CentralManager: extract data about room from vicon data
//CentralManager: assign localArea for each group and those coordinates to PPSClients
//ViconDataPublisher: extract data about room from vicon data in and send also to PPSClient
//PPSClient: Compare data received from CentralManager and ViconDataPublisher and determine in which localArea you are
//PPSClient: Choose correct controller accoring to current localArea


#include "ros/ros.h"
#include <stdlib.h>

//include autogenerated headers from srv files
#include "d_fall_pps/RateController.h"
#include "d_fall_pps/AngleController.h"
#include "d_fall_pps/MotorController.h"
#include "d_fall_pps/CentralManager.h"

//include autogenerated headers from msg files
#include "d_fall_pps/ViconData.h"
#include "d_fall_pps/AngleCommand.h"
#include "d_fall_pps/RateCommand.h"
#include "d_fall_pps/MotorCommand.h"
#include "d_fall_pps/CrazyflieContext.h"


using namespace d_fall_pps;

//the teamname and the assigned crazyflie, will be extracted from studentParams.yaml
std::string team; //is this needed here? maybe for room asignment received from CentralManager?
std::string cflie;

//global sevices
ros::ServiceClient safeController;
ros::ServiceClient centralClient;

ros::Publisher angleCommandPublisher;
ros::Publisher rateCommandPublisher;
ros::Publisher motorCommandPublisher;

//msg for safeController Output
RateCommand safeRateCommandPkg;

//uncommenting the next line causes FATAL Error at runtime: "You must call ros::init() before creating the first NodeHandle"
//ros::NodeHandle nodeHandle;

AreaBounds localArea;


//struct consistent with dusans controller
/*
struct ControllerOutput
{
  //ControllerOutput():roll(0),pitch(0),yaw(0),thrust(0),motorCmd1(0),motorCmd2(0),motorCmd3(0),motorCmd4(0) {}
  float roll;
  float pitch;
  float yaw;
  float thrust;
  float motorCmd1;
  float motorCmd2;
  float motorCmd3;
  float motorCmd4;
  uint8_t onboardControllerType;
};

ControllerOutput ControlCommandTest;*/
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<move this section to a separate file that is included


//extract data from "data" and publish/add to service for controller
//not void: sould give back controlldata
void ppsClientToController(ViconData data, bool autocontrolOn){
	if(data.crazyflieName == cflie){
		//call safecontroller if autocontrol is true
		//safeRateCommandPkg.motorCmd1 = 0;
		//safeRateCommandPkg.motorCmd2 = 0;
		//safeRateCommandPkg.motorCmd3 = 0;
		//safeRateCommandPkg.motorCmd4 = 0;
		if(autocontrolOn){
			return;
			//call safecontroller here
		}
		else {
			//student controller is called here
				//for the moment use safecontroller for TESTING
			
			RateController srvRate;
			Setpoint goalLocation;

			goalLocation.x = -5; //testvalue
			goalLocation.y = 250; //testvalue
			goalLocation.z = 300; //testvalue

			srvRate.request.crazyflieLocation = data;
			srvRate.request.setpoint = goalLocation;

			//TODO:
			//return control commands
			if(safeController.call(srvRate)){
				ROS_INFO("Received control input");
				ROS_INFO_STREAM(srvRate.response.controlOutput);
				
				
				safeRateCommandPkg.rollRate = srvRate.response.controlOutput.rollRate;
				safeRateCommandPkg.pitchRate = srvRate.response.controlOutput.pitchRate;
				safeRateCommandPkg.yawRate = srvRate.response.controlOutput.yawRate;
				safeRateCommandPkg.thrust = srvRate.response.controlOutput.thrust;
  				//onboardControllerType = ??????????????????????
				
				
			}
			else{
				ROS_ERROR("Failed to call SafeControllerService");
				//return 1; //return some useful stuff
			}
		}

		
	}
	else {
		ROS_INFO("ViconData from other crazyflie received");
	}
}

//acceptance test for crazyflie position and attitude 
bool safetyCheck(ViconData data){
	CrazyflieContext CrazyflieContext;
	//ROS_INFO("in safetyCheck");
	//ROS_INFO_STREAM("ViconData: " << data.x << ", " << data.y << ", " << data.z);
	
	//position check
	if((data.x < localArea.xmin) or (data.x > localArea.xmax)){
		return true;
	}
	if((data.y < localArea.ymin) or (data.y > localArea.ymax)){
		return true;
	}
	if((data.z < localArea.zmin) or (data.z > localArea.zmax)){
		return true;
	}
	
	//attitude check
	
	//all checks passed
	return false;
}

//is called upon every new arrival of data in main
void viconCallback(const ViconData& data){
	//ROS_INFO("in viconCallback"); 
	//ROS_INFO_STREAM(data);
	//ROS_INFO("My teamname is:"); ROS_INFO_STREAM(team);
	//ROS_INFO("My crazyflie is:"); ROS_INFO_STREAM(cflie);

	if(data.crazyflieName == cflie){	
		//forward data to safety check
		bool autocontrolOn = safetyCheck(data);
		//ROS_INFO_STREAM("autocontrolOn: " << autocontrolOn);
		ppsClientToController(data, autocontrolOn);
	}
	else {
		ROS_INFO("ViconData from other crazyflie received");
	}


}



//callback method to publish d_fall_pps::AngleCommand
void callbackAngleCommand(const ros::TimerEvent&)
{
	AngleCommand angleCommandPkg;
	angleCommandPkg.rollAngle = 1;
	angleCommandPkg.pitchAngle = 1;
	angleCommandPkg.yawAngle = 1;
	angleCommandPkg.thrust = 50;
	
	angleCommandPublisher.publish(angleCommandPkg);
	ROS_INFO_STREAM("AngleCommandTimer pubslishes: " << angleCommandPkg.rollAngle << ", " << angleCommandPkg.pitchAngle << ", " << angleCommandPkg.yawAngle);
}

//callback method to publish d_fall_pps::RateCommand
void callbackRateCommand(const ros::TimerEvent)
{
	//d_fall_pps::RateCommand rateCommandPkg;
	//rateCommandPkg.rollRate = ...;
	//rateCommandPkg.pitchRate = ...;
	//rateCommandPkg.yawRate = ...;
	//rateCommandPkg.thrust = ...,
	
	
	//Achtung: gepublisht wird safeRateCommandPkg vom Type d_fall_pps::RateCommand >>>> brauchen wir eine separate callback fuer die commands des safetyController benoetigt?????
	rateCommandPublisher.publish(safeRateCommandPkg);
	ROS_INFO_STREAM("RateCommandTimer pubslishes: " << safeRateCommandPkg.rollRate << ", " << safeRateCommandPkg.pitchRate << ", " << safeRateCommandPkg.yawRate);
}

//callback method to publish d_fall_pps::MotorCommand
void callbackMotorCommand(const ros::TimerEvent&)
{
	d_fall_pps::MotorCommand motorCommandPkg;
	//motorCommandPkg.cmd1 = ControlCommandTest.motorCmd1;
	//motorCommandPkg.cmd2 = ControlCommandTest.motorCmd2;
	//motorCommandPkg.cmd3 = ControlCommandTest.motorCmd3;
	//motorCommandPkg.cmd4 = ControlCommandTest.motorCmd4;
	
	motorCommandPublisher.publish(motorCommandPkg);
	ROS_INFO_STREAM("MotorCommandTimer pubslishes: " << motorCommandPkg.cmd1 << ", " << motorCommandPkg.cmd2 << ", " << motorCommandPkg.cmd3 << ", " << motorCommandPkg.cmd4);
}




int main(int argc, char* argv[]){
	ROS_INFO_STREAM("PPSClient started");

	ros::init(argc, argv, "PPSClient");
	ros::NodeHandle nodeHandle("~");

	//get the params defined in studentParams.yaml
	if(!nodeHandle.getParam("TeamName",team)){
		ROS_ERROR("Failed to get TeamName");
	}

	if(!nodeHandle.getParam("CrazyFlieName",cflie)){
		ROS_ERROR("Failed to get CrazyFlieName");
	}
	
	ros::Subscriber ViconSubscriber = nodeHandle.subscribe("/ViconDataPublisher/ViconData", 1, viconCallback);
	ROS_INFO_STREAM("successfully subscribed to ViconData");
	
	
	//ros::Timers to call method that publishes controller outputs for crayzradio node
	/*
	Timers let you schedule a callback to happen at a specific rate through the same callback queue mechanism used by subscription, service, etc. callbacks. 
	Timers are not a realtime thread/kernel replacement, rather they are useful for things that do not have hard realtime requirements. 
	Reference: http://wiki.ros.org/roscpp/Overview/Timers
	*/
    ROS_INFO("creating publishers for package_for_crazyradio");
	ros::Timer angleCommandTimer = nodeHandle.createTimer(ros::Duration(0.1), callbackAngleCommand);
	ros::Timer rateCommandTimer = nodeHandle.createTimer(ros::Duration(0.1), callbackRateCommand);
	ros::Timer motorCommandTimer = nodeHandle.createTimer(ros::Duration(0.1), callbackMotorCommand);
	
	
	//ros::Publishers to advertise on the three command type topics
	angleCommandPublisher = nodeHandle.advertise <AngleCommand>("AngleCommand", 1);
	rateCommandPublisher = nodeHandle.advertise<RateCommand>("RateCommand", 1);
	motorCommandPublisher = nodeHandle.advertise <MotorCommand>("MotorCommand", 1);


	//service 
		//to be expanded with additional services depending on controller (currently only one available)
	safeController = nodeHandle.serviceClient<RateController>("/SafeControllerService/RateController");
	
	//safeController = nodeHandle.serviceClient<d_fall_pps::RateController>("/SafeControllerService/RateController", true);
	//http://wiki.ros.org/roscpp/Overview/Services 
	//2.1 Persistenct Connection: ROS also allows for persistent connections to services. With a persistent connection, a client stays connected to a service. 
	// Otherwise, a client normally does a lookup and reconnects to a service each time.


	//service 
	centralClient = nodeHandle.serviceClient<CentralManager>("/CentralManagerService/CentralManager");
	
	
	//TBD: some sort of init procedure to get data from CentralManager upfront
	//this is only for testing>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	CentralManager ManagerSettings;
	if(centralClient.call(ManagerSettings)){

		localArea = ManagerSettings.response.context.localArea;
		ROS_INFO("CentralManager responded");
		ROS_INFO("localAreaBoundaries Set");
		

	}
	else{
		ROS_ERROR("Failed to call CentralManagerService. Callback is aborted");
		//return some useful stuff
		return 0;
	}
	//<<<<<<<<<<<<<<<<<<<<<<<this is only for testing

    ros::spin();
    return 0;
}
